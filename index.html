<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>もじぴったん 検索ツール</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 2rem;
      line-height: 1.6;
    }
    input {
      font-size: 1.1rem;
      padding: 0.4rem;
      width: 12rem;
    }
    ul {
      margin-top: 1rem;
      padding-left: 0;
      list-style: none; /* リストの・を消して見やすく */
    }
    li {
      margin-bottom: 0.5rem;
      border-bottom: 1px solid #eee; /* 区切り線 */
      padding-bottom: 0.5rem;
    }
    /* 見やすくするための装飾 */
    .word-reading {
      font-weight: bold;
      color: #007bff;
      margin-right: 0.5em;
    }
    .word-notation {
      font-weight: bold;
      margin-right: 0.5em;
    }
    .word-meaning {
      color: #555;
      font-size: 0.9em;
    }
    /* 1. 後ろに続く（Next）: 水色 */
.extend-next {
  background-color: #e1f5fe;
  border-left-color: #03a9f4;
}
.extend-next::after {
  content: ' ➡';
  color: #03a9f4;
}

/* 2. 前に付く（Prev）: 緑色 */
.extend-prev {
  background-color: #e8f5e9;
  border-left-color: #4caf50;
}
.extend-prev::before {
  content: '⬅ ';
  color: #4caf50;
}

/* 3. 両方（Both）: オレンジ/ピンク */
.extend-both {
  background-color: #fff3e0;
  border-left-color: #ff9800;
}
.extend-both::before {
  content: '⬅ ';
  color: #ff9800;
}
.extend-both::after {
  content: ' ➡';
  color: #ff9800;
}
  </style>
</head>
<body>
  <h1>もじぴったん 辞書検索</h1>

  <p>
    検索文字列(２文字以上)を入力すると、<br>
    その文字列を含む「読み」を持つ単語を表示します。<br>
    前や後ろに一文字加えることで別の単語になる場合、そこに矢印を表示します。
  </p>

  <input id="query" placeholder="例：あい" />

  <ul id="results"></ul>

  <script>
    // 小書き仮名 → 通常仮名
    const normalizeMap = {
      'ぁ':'あ','ぃ':'い','ぅ':'う','ぇ':'え','ぉ':'お',
      'ゃ':'や','ゅ':'ゆ','ょ':'よ','っ':'つ','ゎ':'わ'
    };

    function normalize(str) {
      return str
        .split('')
        // カタカナ → ひらがな
        .map(c => {
          const code = c.charCodeAt(0);
          if (code >= 0x30A1 && code <= 0x30F6) {
            return String.fromCharCode(code - 0x60);
          }
          return c;
        })
        // 小文字 → 大文字
        .map(c => normalizeMap[c] || c)
        .join('');
    }


    // ...（normalize関数などはそのまま）...

let dictionary = [];
    // 高速検索用マップ (key: 読み, value: オブジェクトの配列)
    const dictionaryMap = new Map();
    
    fetch('dictionary.json')
      .then(res => res.json())
      .then(data => {
        // 1. データ整形 & マップ登録
        dictionary = data
          .filter(e => e.reading && e.reading.length > 0)
          .map(e => {
            const item = {
              searchKey: normalize(e.reading),
              reading: e.reading,
              notation: e.notation,
              meaning: e.meaning,
              // ▼ 2つのフラグを用意（初期値false）
              canExtendNext: false, // 後ろに足せる
              canExtendPrev: false  // 前に足せる
            };
            return item;
          });

        // マップに登録（同音異義語対応のため配列に入れる）
        dictionary.forEach(item => {
          if (!dictionaryMap.has(item.searchKey)) {
            dictionaryMap.set(item.searchKey, []);
          }
          dictionaryMap.get(item.searchKey).push(item);
        });

        // 2. 「逆引き」でつながりを事前計算
        dictionary.forEach(longWord => {
          const k = longWord.searchKey;
          if (k.length < 2) return; // 1文字からは削れないのでスキップ

          // --- パターンA: 後ろにつながるか？ ---
          // 長い単語(りんごあ) の「末尾」を削ると、短い単語(りんご)になる
          const subNext = k.slice(0, -1);
          if (dictionaryMap.has(subNext)) {
            // 短い単語たちに「後ろOK」フラグを立てる
            dictionaryMap.get(subNext).forEach(w => w.canExtendNext = true);
          }

          // --- パターンB: 前につながるか？ ---
          // 長い単語(おりんご) の「先頭」を削ると、短い単語(りんご)になる
          const subPrev = k.slice(1);
          if (dictionaryMap.has(subPrev)) {
            // 短い単語たちに「前OK」フラグを立てる
            dictionaryMap.get(subPrev).forEach(w => w.canExtendPrev = true);
          }
        });
      });

    const input = document.getElementById('query');
    const results = document.getElementById('results');

    input.addEventListener('input', () => {
      const q = normalize(input.value.trim());
      results.innerHTML = '';
      if (!q || q.length < 2) return;

      const matches = dictionary
        .filter(e => e.searchKey.includes(q))
        .sort((a, b) => a.searchKey.length - b.searchKey.length);

      for (const m of matches) {
        const li = document.createElement('li');

        // ▼ フラグの状態を見てクラスを振り分け
        if (m.canExtendPrev && m.canExtendNext) {
          li.classList.add('extend-both');
          li.title = "前にも後ろにも、文字を足せます";
        } else if (m.canExtendNext) {
          li.classList.add('extend-next');
          li.title = "後ろに文字を足せます";
        } else if (m.canExtendPrev) {
          li.classList.add('extend-prev');
          li.title = "前に文字を足せます";
        }

        li.innerHTML = `
          <span class="word-reading">${m.reading}</span>
          <span class="word-notation">【${m.notation || '-'}】</span>
          <span class="word-meaning">${m.meaning || ''}</span>
        `;
        results.appendChild(li);
      }
    });
  </script>
</body>
</html>
