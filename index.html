<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>もじぴったん 検索ツール</title>
  <style>
    body {
    font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Segoe UI", sans-serif;
    margin: 1rem; /* スマホだと2remは広すぎるので少し狭める */
    line-height: 1.6;
    background-color: #f9f9f9; /* 背景を少しグレーにして白を目立たせる */
    color: #333;
  }

  /* 入力欄のスマホ最適化 */
  input {
    font-size: 16px; /* 【重要】iOSで勝手にズームされないサイズ */
    padding: 12px 15px; /* 指で押しやすいように上下の余白をたっぷり取る */
    width: 100%;     /* 画面幅いっぱいに */
    box-sizing: border-box; /* paddingを含めて100%にする設定 */
    border: 1px solid #ccc;
    border-radius: 8px; /* 角を丸くしてモダンに */
    margin-bottom: 1rem;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05); /* うっすら影をつける */
  }

  /* リスト全体 */
  ul {
    margin-top: 0.5rem;
    padding-left: 0;
    list-style: none;
  }

  /* 各リスト項目 */
  li {
    background-color: #fff; /* 背景を白くしてカードっぽく */
    margin-bottom: 0.8rem;  /* 下との間隔を広げる */
    padding: 1rem;          /* 内側の余白を大きく取って見やすく */
    border-radius: 6px;     /* カードの角丸 */
    box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* 少し浮かせる */
    
    /* 前回追加したボーダー設定のベース */
    border-left: 6px solid #ddd; /* デフォルトはグレー */
    transition: transform 0.1s;
  }
  /* --- 文字サイズの調整 --- */
  
  /* 読み（メイン）: 大きく太く */
  .word-reading {
    display: block; /* 改行して一行使う */
    font-size: 1.4rem;
    font-weight: bold;
    color: #333;
    margin-bottom: 0.2rem;
  }
  
  /* 表記: 少し控えめに */
  .word-notation {
    font-size: 1rem;
    font-weight: bold;
    color: #555;
    margin-right: 0.5rem;
  }
  
  /* 意味: 普通のサイズ */
  .word-meaning {
    font-size: 0.95rem;
    color: #666;
    display: inline-block; /* 必要に応じて改行などの制御をしやすく */
  }
    /* 見やすくするための装飾 */
    .word-reading {
      font-weight: bold;
      color: #007bff;
      margin-right: 0.5em;
    }
    .word-notation {
      font-weight: bold;
      margin-right: 0.5em;
    }
    .word-meaning {
      color: #555;
      font-size: 0.9em;
    }
    /* 1. 後ろに続く（Next）: 水色 */
.extend-next {
  background-color: #e1f5fe;
  border-left-color: #03a9f4;
}
.extend-next::after {
  content: ' ➡';
  color: #03a9f4;
}

/* 2. 前に付く（Prev）: 緑色 */
.extend-prev {
  background-color: #e8f5e9;
  border-left-color: #4caf50;
}
.extend-prev::before {
  content: '⬅ ';
  color: #4caf50;
}

/* 3. 両方（Both）: オレンジ/ピンク */
.extend-both {
  background-color: #fff3e0;
  border-left-color: #ff9800;
}
.extend-both::before {
  content: '⬅ ';
  color: #ff9800;
}
.extend-both::after {
  content: ' ➡';
  color: #ff9800;
}
  </style>
</head>
<body>
  <h1>もじぴったん 辞書検索</h1>

  <p>
    検索文字列(２文字以上)を入力すると、<br>
    その文字列を含む「読み」を持つ単語を表示します。<br>
    前や後ろに一文字加えることで別の単語になる場合、そこに矢印を表示します。
  </p>

  <input id="query" placeholder="例：あい" />

  <ul id="results"></ul>

  <script>
    // 小書き仮名 → 通常仮名
    const normalizeMap = {
      'ぁ':'あ','ぃ':'い','ぅ':'う','ぇ':'え','ぉ':'お',
      'ゃ':'や','ゅ':'ゆ','ょ':'よ','っ':'つ','ゎ':'わ'
    };

    function normalize(str) {
      return str
        .split('')
        // カタカナ → ひらがな
        .map(c => {
          const code = c.charCodeAt(0);
          if (code >= 0x30A1 && code <= 0x30F6) {
            return String.fromCharCode(code - 0x60);
          }
          return c;
        })
        // 小文字 → 大文字
        .map(c => normalizeMap[c] || c)
        .join('');
    }


    // ...（normalize関数などはそのまま）...

let dictionary = [];
    // 高速検索用マップ (key: 読み, value: オブジェクトの配列)
    const dictionaryMap = new Map();
    
    fetch('dictionary.json')
      .then(res => res.json())
      .then(data => {
        // 1. データ整形 & マップ登録
        dictionary = data
          .filter(e => e.reading && e.reading.length > 0)
          .map(e => {
            const item = {
              searchKey: normalize(e.reading),
              reading: e.reading,
              notation: e.notation,
              meaning: e.meaning,
              // ▼ 2つのフラグを用意（初期値false）
              canExtendNext: false, // 後ろに足せる
              canExtendPrev: false  // 前に足せる
            };
            return item;
          });

        // マップに登録（同音異義語対応のため配列に入れる）
        dictionary.forEach(item => {
          if (!dictionaryMap.has(item.searchKey)) {
            dictionaryMap.set(item.searchKey, []);
          }
          dictionaryMap.get(item.searchKey).push(item);
        });

        // 2. 「逆引き」でつながりを事前計算
        dictionary.forEach(longWord => {
          const k = longWord.searchKey;
          if (k.length < 2) return; // 1文字からは削れないのでスキップ

          // --- パターンA: 後ろにつながるか？ ---
          // 長い単語(りんごあ) の「末尾」を削ると、短い単語(りんご)になる
          const subNext = k.slice(0, -1);
          if (dictionaryMap.has(subNext)) {
            // 短い単語たちに「後ろOK」フラグを立てる
            dictionaryMap.get(subNext).forEach(w => w.canExtendNext = true);
          }

          // --- パターンB: 前につながるか？ ---
          // 長い単語(おりんご) の「先頭」を削ると、短い単語(りんご)になる
          const subPrev = k.slice(1);
          if (dictionaryMap.has(subPrev)) {
            // 短い単語たちに「前OK」フラグを立てる
            dictionaryMap.get(subPrev).forEach(w => w.canExtendPrev = true);
          }
        });
      });

    const input = document.getElementById('query');
    const results = document.getElementById('results');

    input.addEventListener('input', () => {
      const q = normalize(input.value.trim());
      results.innerHTML = '';
      if (!q || q.length < 2) return;

      const matches = dictionary
        .filter(e => e.searchKey.includes(q))
        .sort((a, b) => a.searchKey.length - b.searchKey.length);

      for (const m of matches) {
        const li = document.createElement('li');

        // ▼ フラグの状態を見てクラスを振り分け
        if (m.canExtendPrev && m.canExtendNext) {
          li.classList.add('extend-both');
          li.title = "前にも後ろにも、文字を足せます";
        } else if (m.canExtendNext) {
          li.classList.add('extend-next');
          li.title = "後ろに文字を足せます";
        } else if (m.canExtendPrev) {
          li.classList.add('extend-prev');
          li.title = "前に文字を足せます";
        }

        li.innerHTML = `
          <span class="word-reading">${m.reading}</span>
          <span class="word-notation">【${m.notation || '-'}】</span>
          <span class="word-meaning">${m.meaning || ''}</span>
        `;
        results.appendChild(li);
      }
    });
  </script>
</body>
</html>
